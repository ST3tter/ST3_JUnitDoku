%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titel:   JUnit
% Autor:   
% Datum:   
% Version: 0.0.0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%:::Change-Log:::
% Versionierung erfolgt auf folgende Gegebenheiten: -1. Release Versionen
%                                                   -2. Neue Kapitel
%                                                   -3. Fehlerkorrekturen
%
% 0.0.0       Erstellung der Datei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{JUnit}\label{ch:junit}
	\textsf{JUnit}\cite{lit:junit} ist ein Unit-Test-Framework f"ur Java-Code und gehört zur Framework-Familie \textsf{xUnit}. Mit Hilfe von \textsf{JUnit} können Testklassen erstellt werden, die bestimme Bereiche oder Klassen einer Java-Software testen. Meist werden in einer Testklasse einzelne Methoden oder das Zusammenspiel von bestimmten Methoden einer oder mehrerer Klassen getestet.\par
	%
	In Kapitel \ref{ch:testerstellen} ab Seite \pageref{ch:testerstellen} ist eine Schritt f"ur Schritt Anleitung f"ur das Erstellen eines JUnit-Tests zu finden. Diese Tutorial zeigt die grundlegenden Funktionen von \textsf{JUnit} anhand eines einfachen Beispiels auf. Weitere Anleitungen, sowie Tips und Tricks zu diesem Thema sind haufenweise im Internet\footnote{Gute Informationsquellen sind das \hyperlink{https://github.com/junit-team/junit/wiki}{\textsf{JUnit} Wiki}\cite{lit:wiki}  oder die beiden Tutorials \hyperlink{http://www.tutego.de/blog/javainsel/2010/04/junit-4-tutorial-java-tests-mit-junit/}{JUnit 4 Tutorial, Java-Tests mit JUnit}\cite{lit:tutorial1} und \hyperlink{http://www.vogella.com/tutorials/JUnit/article.html}{Unit Testing with JUnit - Tutorial}\cite{lit:tutorial2}} zu finden. 
	%
	\section{xUnit}\label{s:xunit}
		\textsf{JUnit} gehört zu der Framework-Familie \textsf{xUnit}. Verschiedenen Unit-Test Umgebungen für diverse Programmiersprachen werden mit dem Begriff \textsf{xUnit} zusammengefasst. Das x in \textsf{xUnit} stellt dabei ein Platzhalter zur Identifikation der zu testenden Programmiersprache des Frameworks dar. In den meisten F"allen wird das x mit den ersten Buchstaben der Programmiersprache ersetzt (z.B. CUnit für C oder JUnit für Java).\par
		%
		\textsf{xUnit} umfasst bei weitem nicht alle Frameworks für das Unit-Testing. Im Internet ist eine grosse Auswahl an verfügbaren Alternativen zur \textsf{xUnit} Familie zu finden. Unter \hyperlink{http://de.wikipedia.org/wiki/Liste_von_Modultest-Software}{Wikipedia - Liste von Modultest-Software}\cite{lit:unittestlist} ist eine Auflistung von Test-Frameworks für diverse Programmiersprachen vorhanden.   
		%
	\newpage
	\section{Funktionsweise}\label{s:funktionsweise}
		Das Framework \textsf{JUnit} bietet verschiedene Funktionen um Java Software zu testen. Mit sogenannten Annotationen können den Methoden bestimmte Aufgaben für die Test zugeordnet werden. Eine Auflistung dieser ist im Kapitel \ref{ss:annotationen} zu finden. Wurde ein Test Case erstellt und die Testmethoden implementiert, so kann mit diversen Tests, so genannte Asserts, die Funktionalität der Software geprüft werden.\par
		%
		In den folgenden drei Kapiteln wird etwas genauer auf den Aufbau und die Möglichkeiten eines Test mit \textsf{JUnit} eingegangen.
		%
	\subsection{Test Cases}\label{ss:testcase}
		In einem Test Case wird eine ganze Klasse getestet. Hierzu wird eine neue Testklasse erstellt und die entsprechenden Testfälle implementiert. Im Listing \ref{list:bsptestklasse} ist ein kleines Beispiel für eine solche Testklasse abgebildet.\par
		%
\begin{lstlisting}[style=JAVA,caption={Beispiel einer Testklasse},label={list:bsptestklasse}]
package ApplicationCodeTest;		// <-- Eigenes Testpacket

import static org.junit.Assert.*;	// <-- JUnit Assert includes
import org.junit.Test;			// <-- JUnit includes

import ApplicationCode.ClassName;	// <-- Zu testende Klasse einbinden

/* Test Klasse */
public class ClassNameTest {

	@Test	// <-- @Test Annotation identifiziert methode als Testmethode
	public void methodOne() {
	
		/* Test Code für diese Methode hier einfügen */
		
	}

	@Test	// <-- @Test Annotation identifiziert methode als Testmethode
	public void methodTwo() {
	
		/* Test Code für diese Methode hier einfügen */
		
	}
}
\end{lstlisting}
		%
		Die beiden Testmethoden (Zeile 11-16 und 18-23) prüfen jeweils die Funktionalität einer Methode. Vor der Testmethode wird mit der \textsf{@Test} Annotation die Methode als Testmethode definiert. Mehr Informationen zu den Annotationen sind im folgenden Kapitel \ref{ss:annotationen} beschrieben. Nebst der zu testenden Klasse, müssen noch zwei weitere Dateien für das JUnit-Framework in die Klasse eingebunden werden. 
		%
	\newpage
	\subsection{Annotationen}\label{ss:annotationen}
		Annotationen werden benötigt, um einer Methode ein Typ zuzuweisen.
		Wird zum Beispiel \textsf{@Test} vor eine Methode geschrieben, so wird diese vom JUnit-Framework als Testmethode registriert und als solche ausgeführt.\par
		%
		Es stehen folgende Annotationen zur Verfügung:
		%
		\begin{description}
			\item[@Test] Diese Annotation identifiziert eine Methode als Testmethode.
			%
			\item[@Test (expected = Exception.class)] Die Testmethode gibt einen Fehler aus, wird die erwartete Exeption nicht ausgel"ost
			% 
			\item[@Test(timeout=100)] Die Testmethode bricht nach <timeout> Millisekunden ab und gibt einen Fehler aus.
			%
			\item[@Ignore] Mit Hilfe dieser Annotation kann eine Testmethode ignoriert werden.
			%
			\item[@Before] Eine Methode, die mit der \textsf{@Before} Annotation gekennzeichnet ist, wird vor jedem Test ausgeführt.
			% 
			\item[@After] Dies ist das Gegenstück zur \textsf{@Before} Annotation. Methoden mit \textsf{@After} gekennzeichnet, werden nach jedem Test durchlaufen.
			%
			\item[@BeforeClass] Methoden mit der \textsf{@BeforeClass} Annotation werden nur einmal, ganz zu Beginn des Testdurchlaufes, ausgeführt.
			% 
			\item[@AfterClass] Wiederum das Gegenstück zur \textsf{@BeforeClass} Annotation ist \textsf{@AfterClass}. Diese Methoden werden ganz am Ende des Tests durchlaufen.
		\end{description}
		%
	\newpage
	\subsection{Asserts}\label{ss:asserts}
		Mit den Asserts wird die eigentliche Prüfung des Codes realisiert. Asserts sind Mthoden, die zum Beispiel die Gleichheit zweier Werte vergleicht und im Fehlerfall ein Fehler ausgeben.\par
		%
		Folgende Methoden für die Prüfung des Codes stehen dem Benutzer zur Verfügung:
		%
		\begin{description}
			\item[fail(message)] Diese Methode kann verwendet werden, wenn zum Beispiel eine Testmethode noch nicht implementiert wurde. Wird \textsf{fail(message)} aufgerufen, so wird automatisch ein Fehler mit der übergebenen Fehlermeldung ausgegeben. 
			%
			\item[assertTrue({[}message{]}, boolean condition)] Diese Methode erwartet, dass die condition den Wert true annimmt. Ansonsten wird ein Fehler für diesen Test zurückgegeben. 
			% 
			\item[assertFalse({[}message{]}, boolean condition)] "Aquivalent zur \textsf{assertTrue}-Methode wird in diesem Fall der wert false erwartet, damit der Test erfüllt ist.
			%
			\item[assertEquals({[}message{]}, expected, actual)] \textsf{assertEquals} prüft auf die Gleichheit von den Eingaben expected und actual. Oft wird bei expected ein fester Wert übergeben und bei actual das Ergebnis einer Methode.
			%
			\item[assertEquals({[}message{]}, expected, actual, tolerance)] Erweiternd zu dieser Methode kann zusätzlich auch eine Toleranz angegeben werden, welche die maximale Abweichung der beiden Werte definiert.
			% 
			\item[assertNull({[}message{]}, object)] "Uberprüft, ob ein Object gleich Null ist. Anderenfalls wird ein Fehler ausgegeben.
			%
			\item[assertNotNull({[}message{]}, object)] Soll sichergestellt werden, dass ein Objekt ungleich Null ist, so kann diese Testmethode verwendet werden.
			% 
			\item[assertSame({[}message{]}, expected, actual)] Diese Methode kontrolliert, ob beide übergebenen Variablen auf das gleiche Objekt zeigen.
			% 
			\item[assertNotSame({[}message{]}, expected, actual)] Methode, um die Ungleichheit zweier Variablen zu testen.
		\end{description}
		%
		Allen Assert-Methoden kann optional eine Nachricht mitgegeben werde, damit sich die Fehler besser identifizieren und nachvollziehen lässt. Diese Nachricht beinhaltet meistens einen kleinen beschrieb des entsprechenden Tests.